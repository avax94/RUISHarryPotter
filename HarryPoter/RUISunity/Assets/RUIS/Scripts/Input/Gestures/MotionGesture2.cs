//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.IO;


/*
public class MotionGesture2 : RUISGestureRecognizer 
{
	public int _maxSlope = 3;
	
	private readonly string configFolderPath = "C:\\Users\\Nordeus\\Downloads\\gestures.txt"; // todo set it where your txt is;
	
	private int _minimumLength;
	
	DtwGestureRecognizer dtwGestures;
	
	RUISPointTracker2 ruisInput;
	
	double length;
	
	private bool gestureEnabled = false;
	
	private bool gestureState = false;
	
	public override bool GestureIsTriggered()
	{
		return gestureState;
	}
	public override bool GestureWasTriggered()
	{
		//TODO ignore - maybe
		return false;
	}
	
	public override float GetGestureProgress()
	{
		return gestureState ? 1 : 0;
	}
	public override void ResetProgress()
	{
		gestureState = false;
	}
	
	public override void EnableGesture()
	{
		gestureEnabled = true;
	}
	public override void DisableGesture()
	{
		gestureEnabled = false;
	}
	
	public override bool IsBinaryGesture()
	{
		//TODO dafuq is this ? Implement or just leave return false wont use anyway
		
		return false;
	}
	
	void Start()
	{
		dtwGestures = new DtwGestureRecognizer (5, 3, 0);
		Debug.Log ("Reading gestures...");
		dtwGestures.ReadAll (configFolderPath);
		Debug.Log ("Gestures read!");
		ruisInput = (RUISPointTracker2) GetComponent ("RUISPointTracker2");
	}
	
	//ON AWAKE
	//load gesture from config file
	//calculate gesutre circumfence and put in length
	//maybe something more
	void Awake()
	{	
		
		
	}
	private Transform[] colliders;
	public GameObject pathsColls;
	internal List<Vector3> points = new List<Vector3>();
	void Update () 
	{

		Debug.Log ("pp x"+hand.transform.TransformPoint(Vector3.zero).x+" pp y "+hand.transform.TransformPoint(Vector3.zero).y
		           +" pp z"+hand.transform.TransformPoint(Vector3.zero).z);
		PointData newPoint = new PointData(hand.transform.TransformPoint(Vector3.zero), hand.transform.localRotation, timeSinceLastUpdate, Time.timeSinceLevelLoad, previousPoint);
		
		//remove zero velocities just in case, in order for the speeds not to get polluted by nonexisting data
		//if (newPoint.velocity == Vector3.zero) return;
		
		points.Add(newPoint);
		previousPoint = newPoint;
		
		while (points.Count >= bufferLength)
		{
			points.RemoveAt(0);
		}
		//Debug.Log (points.Count + " br");
		int maks = Math.Min (40, points.Count);
		//Debug.Log ("maks " + maks);
		for (int i=0; i<maks; i++) {
			//Debug.Log ("pp x"+points [i].position.x);
			//Debug.Log ("pp y"+points [i].position.y);
			//Debug.Log ("pp z"+points [i].position.z);
			colliders [i].position = points [i].position-new Vector3(0,0,points[i].position.z);
			//colliders[i].position.z = 0;
		}
		Debug.Log ("THREAD ID" + System.Threading.Thread.CurrentThread.ManagedThreadId);
		
		Debug.Log ("brojTacaka" +
		           points.Count);
		if (points.Count > 1) {
			Debug.Log (points [points.Count - 2].position);
			Debug.Log (points [points.Count - 1].position);
		}
		//if (points.Count > bufferSize) points.RemoveAt(0);
		
		//InvalidateCaches();
		
		//Debug.Log(averageSpeed);
		
		timeSinceLastUpdate = 0;



		gestureState = false;
		//NOT SURE IF WE NEED TO check in each iteration. maybe once in some number 
		string recognized = dtwGestures.Recognize (ruisInput.points);
		if (!recognized.Contains("UNKNOWN")) 
		{	
			Debug.Log (recognized);
			gestureState = true;
			//ruisInput.points.Clear();
		}
		
	}
	
	void GestureEvent()
	{
		Debug.Log ("Recognized motion");
	}
}
*/
